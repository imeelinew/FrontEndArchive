# ES6 知识点详解（11-16）

这份文档会用通俗易懂的方式讲解 ES6 中的 6 个重要知识点。

---

## 📌 11. ES6 新增数组方法

### 1. `Array.from()` - 把"假数组"变成"真数组"

**什么是"假数组"（类数组对象）？**

想象你用 `document.querySelectorAll("li")` 获取了页面上所有的 `<li>` 元素，看起来像数组，但它**不是真正的数组**！它不能使用 `push()`、`pop()` 等数组方法。

```javascript
let aLi = document.querySelectorAll("li");
console.log(aLi);  // NodeList(4) [li, li, li, li] - 这是类数组，不是真数组

// 想给它加一个元素？报错！
// aLi.push("5");  // ❌ 报错：aLi.push is not a function
```

**解决方案：用 `Array.from()` 转换**

```javascript
let aLiArr = Array.from(aLi);  // 把类数组转成真数组
aLiArr.push("5");              // ✅ 现在可以用 push 了！
console.log(aLiArr);           // [li, li, li, li, "5"]
```

**通俗理解**：`Array.from()` 就像一个"身份转换器"，把穿着数组外衣的冒牌货变成真正的数组。

---

### 2. `Array.of()` - 创建数组的新方式

**为什么需要它？**

传统的 `new Array()` 有个坑：

```visual basic
let arr1 = new Array(5);    // 创建了一个长度为5的空数组，不是 [5]！
console.log(arr1);          // [empty × 5]

let arr2 = new Array(1,2,3); // 这才是 [1, 2, 3]
```

**`Array.of()` 的行为更直观**

```javascript
let arr3 = Array.of(5);      // [5] - 就是包含数字5的数组
let arr4 = Array.of(1,2,3);  // [1, 2, 3]
```

**通俗理解**：`Array.of()` 就是"我给你什么，你就老老实实装什么"，不会自作聪明。

---

### 3. `fill()` - 批量填充数组

**作用**：把数组的某个范围全部填上同一个值

```javascript
let arr = new Array(5);        // [empty × 5]
arr.fill("1", 0, 3);           // 从索引0开始，填到索引3之前（不包括3）
console.log(arr);              // ["1", "1", "1", empty, empty]
```

**参数说明**：

- 第一个参数：要填充的值
- 第二个参数：开始索引（包含）
- 第三个参数：结束索引（**不包含**）

**通俗理解**：就像用油漆刷墙，告诉它"用什么颜色，从哪刷到哪"。

---

## 📌 12. Symbol - 独一无二的标识符

### 什么是 Symbol？

Symbol 是 ES6 新增的**第七种基本数据类型**，它的特点是：**每个 Symbol 值都是唯一的**。

```javascript
let s1 = Symbol();
let s2 = Symbol();
console.log(s1 === s2);  // false - 即使都是空的，也不相等！
```

### 为什么需要 Symbol？

**场景**：防止对象属性名冲突

假设你拿到别人写的对象，想加个 `username` 属性，但不确定对象里有没有这个属性：

```javascript
let obj = {
    age: 18,
    school: "xxx大学",
    username: "李四"  // 别人写的
}

// 你想加自己的 username
obj.username = "张三";  // ❌ 糟糕！把别人的覆盖了！
```

**用 Symbol 解决**

```javascript
let username = Symbol();  // 创建一个唯一的标识

let obj = {
    age: 18,
    school: "xxx大学"
}

obj[username] = "张三";   // 用 Symbol 作为属性名
console.log(obj[username]); // "张三"
```

**注意**：Symbol 属性必须用 `[]` 访问，不能用 `.`

**通俗理解**：Symbol 就像每个人的身份证号，绝对不会重复，用它做属性名就不用担心撞名了。

---

## 📌 13. 对象扩展

### 1. 属性简写

**当变量名和属性名相同时，可以简写**

```javascript
let age = 18;

// 以前的写法
let obj1 = { age: age };

// ES6 简写
let obj2 = { age };  // 等同于 { age: age }
```

### 2. 方法简写

```javascript
// 以前的写法
let obj1 = {
    talk: function() {
        console.log("说话");
    }
};

// ES6 简写
let obj2 = {
    talk() {
        console.log("说话");
    }
};
```

### 3. 动态属性名（计算属性）

**可以用变量或表达式作为属性名**

```javascript
let key = "age";

let obj = {
    [key]: 18,           // 相当于 age: 18
    [key + "2"]: 20      // 相当于 age2: 20
};

console.log(obj);  // { age: 18, age2: 20 }
```

### 4. `Object.is()` - 更严格的相等判断

```javascript
let a = "hello";
let b = "hello";
console.log(Object.is(a, b));  // true

let obj1 = { name: "张三" };
let obj2 = { name: "张三" };
console.log(Object.is(obj1, obj2));  // false - 两个不同的对象
```

**通俗理解**：`Object.is()` 比较的是"栈内存"中的值，基本类型比值，引用类型比地址。

### 5. `Object.assign()` - 对象合并

**把多个对象的属性合并到一个对象中**

```javascript
let obj1 = { age: 20, school: "北大" };
let obj2 = { username: "张三", age: 30 };

Object.assign(obj1, obj2);
console.log(obj1);  // { age: 30, school: "北大", username: "张三" }
```

**注意**：
- 第一个对象是"接收者"，会被修改
- 后面的对象属性会覆盖前面的同名属性

### 6. `in` 运算符 - 检查属性是否存在

```javascript
let obj = { name: "张三", age: 18 };
console.log("name" in obj);   // true
console.log("school" in obj); // false
```

### 7. `for...in` - 遍历对象

```javascript
let obj = { name: "张三", age: 18, school: "清华" };

for (let key in obj) {
    console.log(key);        // 属性名：name, age, school
    console.log(obj[key]);   // 属性值：张三, 18, 清华
}
```

### 8. `Object.keys()` - 获取所有属性名

```javascript
let obj = { name: "张三", age: 18 };
console.log(Object.keys(obj));  // ["name", "age"]
```

---

## 📌 14. 解构赋值

### 什么是解构赋值？

**一句话**：从数组或对象中"拆包"取值，直接赋给变量。

### 1. 数组解构

```javascript
let arr = ["hello", "world", "你好", "世界"];

// 以前的写法
let str1 = arr[0];  // "hello"
let str2 = arr[1];  // "world"

// ES6 解构写法
let [a, b, c, d] = arr;
console.log(a, b, c, d);  // hello world 你好 世界
```

**按位置一一对应取值**

```javascript
let [first, , third] = [1, 2, 3];  // 跳过第二个
console.log(first, third);  // 1 3
```

### 2. 对象解构

```javascript
let obj = {
    name: "李四",
    age: 18,
    school: "清华大学"
};

// 以前的写法
let name = obj.name;
let age = obj.age;

// ES6 解构写法（按属性名匹配）
let { name, age, school } = obj;
console.log(name, age, school);  // 李四 18 清华大学
```

**设置默认值**

```javascript
let obj = { age: 18 };
let { name = "张三", age } = obj;
console.log(name);  // "张三" - 对象没有name，用默认值
```

### 3. 字符串解构

```javascript
let str = "hello";
let [a, b, c, d, e] = str;
console.log(a, b, c, d, e);  // h e l l o
```

### 4. 函数参数解构

**数组参数解构**

```javascript
function foo([a, b, c]) {
    console.log(a, b, c);
}
foo([1, 2, 3]);  // 1 2 3
```

**对象参数解构（带默认值）**

```javascript
function foo({ a, b, c = 4 }) {
    console.log(a, b, c);
}
foo({ a: 1, b: 2 });  // 1 2 4
```

### 5. 函数返回值解构

```javascript
function getData() {
    return { code: 200, msg: "成功", data: [] };
}

let { code, msg } = getData();
console.log(code, msg);  // 200 成功
```

**通俗理解**：解构赋值就像拆快递，按照包裹里的物品位置或标签，直接把东西拿出来放到对应的盒子里。

---

## 📌 15. 扩展运算符（...）

### 什么是扩展运算符？

三个点 `...` 就是扩展运算符，可以把数组、对象"展开"。

### 1. 数组展开

```javascript
let arr = [1, 2, 3];
console.log(...arr);  // 1 2 3（不是数组，是独立的值）

// 合并数组
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
let arr3 = [...arr1, "a", ...arr2];
console.log(arr3);  // [1, 2, 3, "a", 4, 5, 6]
```

### 2. 字符串展开

```javascript
let str = "hello";
console.log(...str);  // h e l l o
```

### 3. 函数参数收集（剩余参数）

**收集不确定数量的参数**

```javascript
function foo(a, b, ...rest) {
    console.log(a);     // 1
    console.log(b);     // 2
    console.log(rest);  // [3, 4, 5, 6] - 剩余的参数
}
foo(1, 2, 3, 4, 5, 6);
```

**注意**：剩余参数必须放在最后

### 4. 对象展开（浅拷贝）

```javascript
let obj1 = { name: "张三", age: 18 };
let obj2 = { ...obj1, school: "清华" };  // 复制并添加新属性

obj1.name = "李四";
console.log(obj2.name);  // "张三" - 不受影响，是独立的副本
```

**对比引用赋值**

```javascript
let obj1 = { name: "张三" };
let obj2 = obj1;  // 引用赋值，指向同一个对象

obj1.name = "李四";
console.log(obj2.name);  // "李四" - 受影响了！
```

**通俗理解**：
- **展开**：把包裹打开，把里面的东西一个个摊出来
- **收集**：把散落的东西装进一个包裹里

---

## 📌 16. this 指向与改变 this

### this 的基本规则

**一句话**：谁调用函数，this 就指向谁。

### 情况1：事件绑定

```javascript
let box = document.querySelector(".box");
box.onclick = function() {
    console.log(this);  // 指向 box 元素
}
```

### 情况2：对象方法

```javascript
let obj = {
    name: "张三",
    say() {
        console.log(this.name);  // this 指向 obj
    }
}
obj.say();  // "张三"
```

### 情况3：普通函数

```javascript
function say() {
    console.log(this);  // this 指向 window
}
say();
```

### 情况4：嵌套函数的坑

```javascript
let obj = {
    name: "张三",
    say() {
        console.log(this);  // 指向 obj ✅

        function inner() {
            console.log(this);  // 指向 window ❌ 不是 obj！
        }
        inner();
    }
}
obj.say();
```

---

### 改变 this 指向的三种方法

JavaScript 提供了三种方法来手动改变函数内部的 `this` 指向：`call()`、`apply()` 和 `bind()`。

---

#### 1. `call()` - 立即调用，参数逐个传

**语法**：`函数.call(新的this指向, 参数1, 参数2, ...)`

**基础例子**：

```javascript
function say(a, b) {
    console.log(a, b, this.name);
}

let obj = { name: "张三" };

// 正常调用：this 指向 window
say(1, 2);  // 1 2 undefined（window 没有 name）

// 使用 call：this 指向 obj
say.call(obj, 1, 2);  // 1 2 张三
```

**详细例子1：借用其他对象的方法**

```javascript
let person1 = {
    name: "张三",
    greet: function(city, country) {
        console.log(`${this.name} 来自 ${city}, ${country}`);
    }
};

let person2 = {
    name: "李四"
};

// person2 没有 greet 方法，但可以借用 person1 的
person1.greet.call(person2, "北京", "中国");
// 输出：李四 来自 北京, 中国
```

**详细例子2：把类数组转成真数组（经典用法）**

```javascript
function foo() {
    // arguments 是类数组，不能直接用 forEach
    console.log(arguments);  // [1, 2, 3]（类数组）
    
    // 借用数组的 slice 方法转成真数组
    let arr = Array.prototype.slice.call(arguments);
    console.log(arr);  // [1, 2, 3]（真数组）
    
    // 现在可以用数组方法了
    arr.forEach(item => console.log(item));
}
foo(1, 2, 3);
```

**详细例子3：判断数据类型（高级用法）**

```javascript
// Object.prototype.toString 可以精确判断数据类型
function getType(value) {
    return Object.prototype.toString.call(value);
}

console.log(getType([]));        // [object Array]
console.log(getType({}));        // [object Object]
console.log(getType(123));       // [object Number]
console.log(getType("hello"));   // [object String]
console.log(getType(null));      // [object Null]
console.log(getType(undefined)); // [object Undefined]
```

---

#### 2. `apply()` - 立即调用，参数用数组传

**语法**：`函数.apply(新的this指向, [参数数组])`

**与 call 的唯一区别**：参数要放在数组里传递

**基础例子**：

```javascript
function say(a, b, c) {
    console.log(a, b, c, this.name);
}

let obj = { name: "张三" };

say.call(obj, 1, 2, 3);     // call：参数一个个传
say.apply(obj, [1, 2, 3]);  // apply：参数放数组里传
// 两个输出都是：1 2 3 张三
```

**详细例子1：求数组最大值（经典用法）**

```javascript
let arr = [5, 2, 9, 1, 7];

// Math.max 不接受数组，但可以用 apply 展开
let max = Math.max.apply(null, arr);  // null 因为不需要改变 this
console.log(max);  // 9

// 等价于 Math.max(5, 2, 9, 1, 7)

// 顺便说一下，ES6 更简单的写法：
let max2 = Math.max(...arr);  // 用扩展运算符
console.log(max2);  // 9
```

**详细例子2：合并数组**

```javascript
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];

// 把 arr2 的元素都 push 到 arr1 里
Array.prototype.push.apply(arr1, arr2);
console.log(arr1);  // [1, 2, 3, 4, 5, 6]

// 等价于 arr1.push(4, 5, 6)
```

**详细例子3：当你已经有一个参数数组时**

```javascript
function introduce(name, age, city) {
    console.log(`我是${name}，${age}岁，来自${city}`);
}

// 假设参数是从某个地方获取的数组
let params = ["张三", 18, "北京"];

// 用 apply 直接传数组
introduce.apply(null, params);  // 我是张三，18岁，来自北京

// 如果用 call 就很麻烦
introduce.call(null, params[0], params[1], params[2]);
```

---

#### 3. `bind()` - 不立即调用，返回新函数

**语法**：`let 新函数 = 函数.bind(新的this指向, 参数1, 参数2, ...)`

**核心特点**：
- **不会立即执行**函数
- 返回一个**新函数**，这个新函数的 this 已经被绑定好了
- 可以预先传入部分参数

**基础例子**：

```javascript
function say(a, b) {
    console.log(a, b, this.name);
}

let obj = { name: "张三" };

// call 和 apply 会立即执行
say.call(obj, 1, 2);   // 立即输出：1 2 张三
say.apply(obj, [1, 2]); // 立即输出：1 2 张三

// bind 不会立即执行，返回一个新函数
let newSay = say.bind(obj, 1, 2);
console.log(newSay);  // 输出的是函数本身，不是执行结果

// 需要手动调用
newSay();  // 现在输出：1 2 张三
```

**详细例子1：事件处理中的 this（最常用场景！）**

```javascript
let user = {
    name: "张三",
    
    init() {
        let btn = document.querySelector("button");
        
        // ❌ 错误写法：this 指向 button，不是 user
        btn.onclick = function() {
            console.log(this.name);  // undefined，this 是 button
        };
        
        // ✅ 正确写法1：用 bind 绑定 this
        btn.onclick = function() {
            console.log(this.name);  // 张三
        }.bind(this);  // 把 user 绑定为 this
        
        // ✅ 正确写法2：用箭头函数（箭头函数没有自己的 this）
        btn.onclick = () => {
            console.log(this.name);  // 张三
        };
    }
};

user.init();
```

**详细例子2：定时器中的 this**

```javascript
let obj = {
    name: "张三",
    
    delayedGreet() {
        // ❌ 错误：1秒后 this 指向 window
        setTimeout(function() {
            console.log("你好，" + this.name);  // 你好，undefined
        }, 1000);
        
        // ✅ 正确1：用 bind
        setTimeout(function() {
            console.log("你好，" + this.name);  // 你好，张三
        }.bind(this), 1000);
        
        // ✅ 正确2：用箭头函数
        setTimeout(() => {
            console.log("你好，" + this.name);  // 你好，张三
        }, 1000);
        
        // ✅ 正确3：保存 this 到变量（老写法）
        let that = this;
        setTimeout(function() {
            console.log("你好，" + that.name);  // 你好，张三
        }, 1000);
    }
};

obj.delayedGreet();
```

**详细例子3：预设参数（柯里化）**

```javascript
function multiply(a, b) {
    return a * b;
}

// 创建一个专门乘以2的函数
let double = multiply.bind(null, 2);
console.log(double(5));   // 10（相当于 multiply(2, 5)）
console.log(double(10));  // 20（相当于 multiply(2, 10)）

// 创建一个专门乘以10的函数
let tenTimes = multiply.bind(null, 10);
console.log(tenTimes(3)); // 30
console.log(tenTimes(7)); // 70
```

**详细例子4：多次 bind（加深理解）**

```javascript
function say() {
    console.log(this.name);
}

let obj1 = { name: "张三" };
let obj2 = { name: "李四" };

let sayHi = say.bind(obj1);
sayHi();  // 张三

// 再次 bind 无效！第一次绑定后就定死了
let sayHi2 = sayHi.bind(obj2);
sayHi2();  // 还是 张三，不是 李四
```

---

### 三者对比

| 对比项 | `call()` | `apply()` | `bind()` |
|:------|:---------|:----------|:---------|
| **是否立即执行** | ✅ 是 | ✅ 是 | ❌ 否 |
| **参数传递方式** | 逐个传递 | 数组传递 | 逐个传递 |
| **返回值** | 函数执行结果 | 函数执行结果 | 新函数 |
| **使用场景** | 借用方法、立即执行 | 参数是数组时 | 事件绑定、定时器 |

---

### 三者的关系图解

```
原函数                call / apply / bind                 结果
   ↓                        ↓                              ↓
function say() {     say.call(obj, 1, 2)         →   立即执行，输出结果
   ...               say.apply(obj, [1,2])       →   立即执行，输出结果
}                    say.bind(obj, 1, 2)         →   返回新函数（不执行）
                                                           ↓
                                                      newSay() → 手动调用
```

---

### 什么时候用哪个？

| 场景 | 推荐使用 |
|:----|:--------|
| 想立即执行函数，参数已知 | `call()` |
| 想立即执行，参数是数组 | `apply()` |
| 事件绑定、定时器回调 | `bind()` |
| 想创建一个预设 this 的新函数 | `bind()` |

---

### 记忆口诀

- **call**：Call 打电话 📞，一个个说清楚（参数一个个传），说完就挂（立即执行）
- **apply**：Apply 写申请表 📝，打包提交（参数打包成数组），交了就完事（立即执行）
- **bind**：Bind 绑定手机号 🔗，先登记好（返回新函数），以后再用（稍后调用）

---

### 常见面试题

**问：以下代码输出什么？**

```javascript
var name = "window";

let obj = {
    name: "obj",
    say: function() {
        console.log(this.name);
    }
};

let obj2 = { name: "obj2" };

obj.say();                    // ?
obj.say.call(obj2);           // ?
obj.say.apply(obj2);          // ?
obj.say.bind(obj2)();         // ?
```

**答案**：
- `obj.say()` → `obj`（谁调用指向谁）
- `obj.say.call(obj2)` → `obj2`（用 call 改变了 this）
- `obj.say.apply(obj2)` → `obj2`（用 apply 改变了 this）
- `obj.say.bind(obj2)()` → `obj2`（bind 返回新函数，立即调用）

---

## 🎯 总结

| 知识点 | 核心内容 |
|:------|---------|
| 11. 数组方法 | `Array.from()` 转真数组、`Array.of()` 创建数组、`fill()` 填充 |
| 12. Symbol | 创建唯一标识符，防止属性名冲突 |
| 13. 对象扩展 | 简写语法、`Object.assign()` 合并、`for...in` 遍历 |
| 14. 解构赋值 | 从数组/对象中快速提取值赋给变量 |
| 15. 扩展运算符 | `...` 展开数组/对象、收集剩余参数 |
| 16. this | 谁调用指向谁、`call`/`apply`/`bind` 改变指向 |

---

*希望这份讲解能帮你理解这些 ES6 知识点！有问题随时问～* 😊
