# ES6 知识点详解（17-18）

这份文档会用通俗易懂的方式讲解原型和判断数据类型这两个重要知识点。

---

## 📌 17. 原型（Prototype）

### 什么是原型？

**一句话**：原型是 JavaScript 中实现**继承**和**共享方法**的机制。

每个对象都有一个"隐藏的爹"，这个"爹"就是**原型对象**。当你在对象上找不到某个属性或方法时，JavaScript 会自动去它的原型上找。

---

### 两个重要的属性

#### 1. `prototype`（原型对象）

**谁有？** 只有**函数**才有 `prototype` 属性。

```javascript
function foo() {
    console.log("hello");
}
console.log(foo.prototype);  // {constructor: ƒ}
```

**作用**：定义在 `prototype` 上的属性和方法，可以被该函数创建的所有实例共享。

#### 2. `__proto__`（原型链接）

**谁有？** 任何**对象**都有 `__proto__` 属性。

```javascript
let arr = [1, 2, 3];
console.log(arr.__proto__);  // 指向 Array.prototype
```

**作用**：指向创建该对象的构造函数的 `prototype`。

---

### 原型链图解

```
实例对象 arr
    │
    └─ arr.__proto__  ──────────▶  Array.prototype
                                        │
                                        └─ Array.prototype.__proto__  ──▶  Object.prototype
                                                                                  │
                                                                                  └─ Object.prototype.__proto__  ──▶  null（终点！）
```

**通俗理解**：就像族谱一样，儿子找不到的东西去找爸爸，爸爸找不到去找爷爷，一直往上找，找到祖宗（`Object.prototype`），再往上就是 `null`（没了）。

---

### 内置类型的原型

```javascript
// 每种数据类型都有自己的原型对象
console.log(Number.prototype);    // 数字的原型
console.log(String.prototype);    // 字符串的原型
console.log(Boolean.prototype);   // 布尔值的原型
console.log(Object.prototype);    // 对象的原型（所有原型的祖宗）
console.log(Function.prototype);  // 函数的原型
console.log(Array.prototype);     // 数组的原型
console.log(Date.prototype);      // 日期的原型
```

**为什么数组可以用 `push`、`pop` 等方法？**

因为这些方法定义在 `Array.prototype` 上，所有数组实例都能通过原型链找到它们！

```javascript
let arr = [1, 2, 3];
arr.push(4);  // push 方法来自 Array.prototype
```

---

### prototype vs __proto__ 对比

| 对比项 | `prototype` | `__proto__` |
|:------|:------------|:------------|
| **谁有** | 只有函数有 | 任何对象都有 |
| **是什么** | 一个对象（原型对象） | 一个指针（指向原型） |
| **作用** | 定义共享的属性和方法 | 查找原型链 |
| **关系** | `Foo.prototype` | `实例.__proto__ === Foo.prototype` |

---

### 实际例子

```javascript
function Person(name) {
    this.name = name;
}

// 在原型上定义方法（所有实例共享）
Person.prototype.sayHello = function() {
    console.log("你好，我是" + this.name);
};

let p1 = new Person("张三");
let p2 = new Person("李四");

p1.sayHello();  // 你好，我是张三
p2.sayHello();  // 你好，我是李四

// 验证原型链
console.log(p1.__proto__ === Person.prototype);  // true
console.log(p2.__proto__ === Person.prototype);  // true

// p1 和 p2 共享同一个 sayHello 方法
console.log(p1.sayHello === p2.sayHello);  // true（同一个方法！）
```

---

### 🎯 总结

- **原型**：每个对象都有一个原型，用于共享属性和方法
- **prototype**：函数的属性，定义共享内容的地方
- **__proto__**：对象的属性，指向它的原型
- **原型链**：对象 → 原型 → 原型的原型 → ... → `null`

**记忆口诀**：
> 找东西先找自己，自己没有找原型，原型没有继续找，找到 null 才死心！

---

## 📌 18. 判断数据类型

JavaScript 有多种判断数据类型的方法，各有优缺点。

### 先准备测试数据

```javascript
let str = "hello";
let num = 10;
let bool = true;
let und = undefined;
let nul = null;
let arr = [1, 2, 3, 4, 5];
let obj = { a: 10 };
let fun = function() { console.log("hello"); };
```

---

### 方法1：`typeof` 运算符

**最常用但有局限性。**

```javascript
console.log(typeof str);   // "string" ✅
console.log(typeof num);   // "number" ✅
console.log(typeof bool);  // "boolean" ✅
console.log(typeof und);   // "undefined" ✅
console.log(typeof nul);   // "object" ❌ 这是个历史遗留bug！
console.log(typeof arr);   // "object" ❌ 分不清是数组还是对象
console.log(typeof obj);   // "object" 
console.log(typeof fun);   // "function" ✅
```

**优点**：简单快速

**缺点**：
- ❌ `null` 返回 `"object"`（历史bug）
- ❌ 数组返回 `"object"`（无法区分数组和对象）

**适用场景**：判断基本类型（除了 `null`）

---

### 方法2：`instanceof` 运算符

**判断对象是否是某个构造函数的实例。**

```javascript
console.log(str instanceof String);     // false ❌（字面量不是 String 对象）
console.log(num instanceof Number);     // false ❌（字面量不是 Number 对象）
console.log(bool instanceof Boolean);   // false ❌（字面量不是 Boolean 对象）
console.log(und === undefined);         // true（只能用 === 判断）
console.log(nul === null);              // true（只能用 === 判断）
console.log(arr instanceof Array);      // true ✅
console.log(obj instanceof Object);     // true ✅
console.log(fun instanceof Function);   // true ✅
```

**优点**：可以判断具体的引用类型（数组、对象、函数等）

**缺点**：
- ❌ 不能判断基本类型的字面量（`"hello"` vs `new String("hello")`）
- ❌ 不能判断 `null` 和 `undefined`

**适用场景**：判断引用类型

---

### 方法3：`constructor` 属性

**通过构造函数判断。**

```javascript
console.log(str.constructor === String);     // true ✅
console.log(num.constructor === Number);     // true ✅
console.log(bool.constructor === Boolean);   // true ✅
// console.log(und.constructor);             // ❌ 报错！undefined 没有 constructor
// console.log(nul.constructor);             // ❌ 报错！null 没有 constructor
console.log(arr.constructor === Array);      // true ✅
console.log(obj.constructor === Object);     // true ✅
console.log(fun.constructor === Function);   // true ✅
```

**优点**：可以判断基本类型的字面量

**缺点**：
- ❌ `null` 和 `undefined` 没有 `constructor`，会报错
- ❌ `constructor` 可以被修改，不够可靠

**适用场景**：判断大部分类型（注意先排除 `null` 和 `undefined`）

---

### 方法4：`Object.prototype.toString.call()`（🌟 最推荐！）

**万能方法，可以精确判断所有类型！**

```javascript
console.log(Object.prototype.toString.call(str));   // [object String]
console.log(Object.prototype.toString.call(num));   // [object Number]
console.log(Object.prototype.toString.call(bool));  // [object Boolean]
console.log(Object.prototype.toString.call(und));   // [object Undefined]
console.log(Object.prototype.toString.call(nul));   // [object Null] ✅ 可以判断 null！
console.log(Object.prototype.toString.call(arr));   // [object Array] ✅ 可以区分数组！
console.log(Object.prototype.toString.call(obj));   // [object Object]
console.log(Object.prototype.toString.call(fun));   // [object Function]
```

**封装成工具函数**：

```javascript
function getType(value) {
    // 返回结果如 "[object Array]"，截取中间的类型名
    return Object.prototype.toString.call(value).slice(8, -1);
}

console.log(getType("hello"));     // "String"
console.log(getType(123));         // "Number"
console.log(getType(true));        // "Boolean"
console.log(getType(undefined));   // "Undefined"
console.log(getType(null));        // "Null"
console.log(getType([]));          // "Array"
console.log(getType({}));          // "Object"
console.log(getType(function(){}));// "Function"
console.log(getType(new Date()));  // "Date"
console.log(getType(/regex/));     // "RegExp"
```

**优点**：
- ✅ 可以判断所有类型
- ✅ 可以区分 `null`、数组、日期、正则等
- ✅ 结果准确可靠

**缺点**：写法稍微复杂

**适用场景**：需要精确判断类型的场合（强烈推荐！）

---

### 方法5：`Array.isArray()`（专门判断数组）

```javascript
console.log(Array.isArray(arr));  // true ✅
console.log(Array.isArray(obj));  // false
console.log(Array.isArray("hello"));  // false
```

**适用场景**：只需要判断是不是数组

---

### 📊 四种方法对比表

| 数据类型 | `typeof` | `instanceof` | `constructor` | `toString.call()` |
|:---------|:---------|:-------------|:--------------|:------------------|
| `"hello"` | ✅ string | ❌ false | ✅ String | ✅ String |
| `123` | ✅ number | ❌ false | ✅ Number | ✅ Number |
| `true` | ✅ boolean | ❌ false | ✅ Boolean | ✅ Boolean |
| `undefined` | ✅ undefined | ❌ 不能用 | ❌ 报错 | ✅ Undefined |
| `null` | ❌ object | ❌ 不能用 | ❌ 报错 | ✅ Null |
| `[1,2,3]` | ❌ object | ✅ Array | ✅ Array | ✅ Array |
| `{a:1}` | ✅ object | ✅ Object | ✅ Object | ✅ Object |
| `function(){}` | ✅ function | ✅ Function | ✅ Function | ✅ Function |

---

### 🎯 实际使用建议

```javascript
// 1. 快速判断基本类型（除了 null）
if (typeof value === 'string') { ... }
if (typeof value === 'number') { ... }

// 2. 判断 null 和 undefined
if (value === null) { ... }
if (value === undefined) { ... }
if (value == null) { ... }  // 同时判断 null 和 undefined

// 3. 判断数组
if (Array.isArray(value)) { ... }

// 4. 精确判断所有类型
function getType(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
}
if (getType(value) === 'Array') { ... }
if (getType(value) === 'Date') { ... }
```

---

### 🎯 总结

| 方法 | 优点 | 缺点 | 推荐指数 |
|:-----|:-----|:-----|:---------|
| `typeof` | 简单快速 | null 返回 object，不能区分数组 | ⭐⭐⭐ |
| `instanceof` | 能判断引用类型 | 不能判断基本类型字面量 | ⭐⭐ |
| `constructor` | 能判断大部分类型 | null/undefined 报错 | ⭐⭐ |
| `toString.call()` | 万能，最准确 | 写法稍复杂 | ⭐⭐⭐⭐⭐ |
| `Array.isArray()` | 专门判断数组 | 只能判断数组 | ⭐⭐⭐⭐ |

**记忆口诀**：
> `typeof` 判基本，`instanceof` 判引用，`toString` 最万能，`isArray` 专门判数组！

---

*希望这份讲解能帮你理解原型和判断数据类型！有问题随时问～* 😊
